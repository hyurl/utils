{"version":3,"file":"index.js","sources":["../../../../../../jsext/esm/promise/index.js"],"sourcesContent":["/** Try to resolve a promise with a timeout limit. */\nasync function timeout(value, ms) {\n    const result = await Promise.race([\n        value,\n        new Promise((_, reject) => setTimeout(() => {\n            reject(new Error(`operation timeout after ${ms}ms`));\n        }, ms))\n    ]);\n    return result;\n}\n/** Resolves a promise only after the given duration. */\nasync function after(value, ms) {\n    const [result] = await Promise.allSettled([\n        value,\n        new Promise(resolve => setTimeout(resolve, ms))\n    ]);\n    if (result.status === \"fulfilled\") {\n        return result.value;\n    }\n    else {\n        throw result.reason;\n    }\n}\n/** Blocks the context for a given time. */\nasync function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n/** Blocks the context until the test is passed. */\nasync function until(test) {\n    if (typeof globalThis.setImmediate === \"undefined\") {\n        // @ts-ignore\n        globalThis.setImmediate = (cb) => setTimeout(cb, 0);\n    }\n    do {\n        await new Promise(globalThis.setImmediate);\n    } while ((await test()) == false);\n}\n\nexport { after, sleep, timeout, until };\n//# sourceMappingURL=index.js.map\n"],"names":[],"mappings":"AAAA;AAuBA;AACA,eAAe,KAAK,CAAC,EAAE,EAAE;AACzB,IAAI,OAAO,IAAI,OAAO,CAAC,OAAO,IAAI,UAAU,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3D,CAAC;AACD;AACA,eAAe,KAAK,CAAC,IAAI,EAAE;AAC3B,IAAI,IAAI,OAAO,UAAU,CAAC,YAAY,KAAK,WAAW,EAAE;AACxD;AACA,QAAQ,UAAU,CAAC,YAAY,GAAG,CAAC,EAAE,KAAK,UAAU,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;AAC5D,KAAK;AACL,IAAI,GAAG;AACP,QAAQ,MAAM,IAAI,OAAO,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;AACnD,KAAK,QAAQ,CAAC,MAAM,IAAI,EAAE,KAAK,KAAK,EAAE;AACtC;;;;"}