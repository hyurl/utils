{"version":3,"file":"index.js","sources":["../node_modules/is-like/index.mjs","../count.ts","../isVoid.ts","../node_modules/could-be-class/index.js","../typeOf.ts","../isEmpty.ts","../node_modules/@ayonli/jsext/number/index.ts","../ensureType.ts","../flatObject.ts","../isBetween.ts","../isFloat.ts","../isNumeric.ts","../node_modules/@ayonli/jsext/object/index.ts","../isOwnKey.ts","../isOwnMethod.ts","../node_modules/@ayonli/jsext/external/check-iterable/index.mjs","../node_modules/@ayonli/jsext/throttle.ts","../node_modules/@ayonli/jsext/chan.ts","../node_modules/@ayonli/jsext/run.ts","../node_modules/@ayonli/jsext/index.ts","../node_modules/@ayonli/jsext/wrap.ts","../isSubClassOf.ts","../node_modules/@ayonli/jsext/isSubclassOf.ts","../omitInvalid.ts","../omitVoid.ts","../patch.ts","../rand.ts","../sleep.ts","../node_modules/@ayonli/jsext/promise/index.ts","../sort.ts","../split.ts","../typeAs.ts","../until.ts","../useThrottle.ts","../wrap.ts","../define.ts","../diff.ts","../getGlobal.ts","../isInteger.ts","../keysOf.ts","../omit.ts","../pick.ts","../randStr.ts","../timestamp.ts","../trim.ts"],"sourcesContent":["/**\n * @param {any} value \n * @param {Array<[string|symbol, string]>} props \n * @param {Array<string>} types\n */\nfunction isObjectWith(value, ...props) {\n    let isObj = typeof value === \"object\" && value !== null;\n    return isObj && props.every(([p, t]) => p in value && typeof value[p] === t);\n}\n\nfunction isEmptyDict(obj) {\n    try {\n        let str = JSON.stringify(obj);\n        return str === \"{}\" || str === \"[]\";\n    } catch (e) {\n        return false;\n    }\n}\n\n/**\n * Checks if the input value is a dict `object`, which includes key-value pairs.\n * @returns {value is { [x: string | symbol]: any; }}\n */\nexport function isDictLike(value) {\n    return typeof value === \"object\" && value !== null\n        && (value.constructor === Object || (\n            !(value instanceof Date) &&\n            !(value instanceof RegExp) &&\n            !isArrayLike(value, true) &&\n            !isObjectIdLike(value) &&\n            !isEmptyDict(value) &&\n            !isTypedArrayLike(value) &&\n            !isCollectionLike(value) &&\n            !isPromiseLike(value)\n        ));\n}\n\n/**\n * Checks if the input value is an `object` with `length` property or a string.\n * @returns {value is ArrayLike<any>}\n */\nexport function isArrayLike(value, strict = false) {\n    if (Array.isArray(value)) {\n        return true;\n    } else if (!strict) {\n        return isObjectWith(value, [\"length\", \"number\"])\n            || (typeof value === \"string\");\n    } else if (isObjectWith(value, [\"length\", \"number\"])) {\n        let keys = Object.keys(value);\n        let isNonEnumLength = !keys.includes(\"length\");\n        let indexes;\n\n        if (value.length === 0 ||\n            (indexes = keys.map(Number).filter(isFinite)).length === 0) {\n            return isNonEnumLength;\n        } else {\n            let hasIterator = typeof value[Symbol.iterator] === \"function\";\n\n            for (let i = value.length; i--;) {\n                if (!indexes.includes(i) && !(isNonEnumLength || hasIterator)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks if the input value is an `object` with `size` property and\n * `[Symbol.iterator]()` method, or is an instance of **WeakMap** or\n * **WeakSet** if `excludeWeakOnes` is not set.\n */\nexport function isCollectionLike(value, excludeWeakOnes = false) {\n    return (isObjectWith(value, [\"size\", \"number\"], [Symbol.iterator, \"function\"]))\n        || (!excludeWeakOnes &&\n            (value instanceof WeakMap || value instanceof WeakSet));\n}\n\n/**\n * \n * @returns {value is ArrayLike<number> & Pick<Uint8Array, \"byteLength\" | \"slice\">}\n */\nexport function isTypedArrayLike(value) {\n    return isObjectWith(value, [\"byteLength\", \"number\"], [\"slice\", \"function\"]);\n}\n\n/** @deprecated An alias of `isTypedArrayLike`. */\nexport const isBufferLike = isTypedArrayLike;\n\n/**\n * Checks if the input value is an `object` with `name`, `message` and `stack`\n * properties.\n * @returns {value is Error}\n */\nexport function isErrorLike(value) {\n    return isObjectWith(value,\n        [\"name\", \"string\"],\n        [\"message\", \"string\"],\n        [\"stack\", \"string\"]\n    );\n}\n\n/**\n * Checks if the input is an `object` with `then()` method.\n * @returns {value is PromiseLike<any>}\n */\nexport function isPromiseLike(value) {\n    return isObjectWith(value, [\"then\", \"function\"]);\n}\n\nexport function isObjectIdLike(value) {\n    return typeof value === \"object\" && value !== null\n        && (value.constructor.name === \"ObjectId\"\n            || value.constructor.name === \"ObjectID\");\n}\n","import { isArrayLike, isBufferLike, isCollectionLike } from \"is-like\";\nconst encoder = new TextEncoder();\nexport default count;\nfunction count(target, option = void 0) {\n    if (typeof target === \"string\") {\n        if (typeof option === \"string\") {\n            if (!option) {\n                return target.length + 1;\n            }\n            else if (!target) {\n                return 0;\n            }\n            return target.split(option).length - 1;\n        }\n        else if (option === true) {\n            if (typeof Buffer === \"function\" &&\n                typeof Buffer.byteLength === \"function\") {\n                return Buffer.byteLength(target);\n            }\n            else {\n                return encoder.encode(target).byteLength;\n            }\n        }\n        else {\n            return target.length;\n        }\n    }\n    else if (isArrayLike(target, true)) {\n        if (arguments.length === 2) {\n            let times = 0;\n            for (let i = target.length; i--;) {\n                // treat 0 equals -0 and NaN equals NaN\n                if (target[i] === option || Object.is(target[i], option)) {\n                    times++;\n                }\n            }\n            return times;\n        }\n        else {\n            return target.length;\n        }\n    }\n    else if (isBufferLike(target)) {\n        return target.byteLength;\n    }\n    else if (isCollectionLike(target, true)) {\n        return target.size;\n    }\n    else {\n        return Object.keys(target).length;\n    }\n}\n//# sourceMappingURL=count.js.map","/**\n * Checks if a value is resolved to void (`null`, `undefined` or `NaN`).\n *\n * @deprecated use `!Object.isValid` from `@ayonli/jsext/object/augment` instead.\n */\nexport default function isVoid(value) {\n    return value === null || value === undefined || Object.is(value, NaN);\n}\n//# sourceMappingURL=isVoid.js.map","\"use strict\";\n\n/**\n * Checks if an object could be an instantiable class.\n * @param {any} obj\n * @returns {obj is new (...args: any[]) => any}\n */\nfunction couldBeClass(obj) {\n    if (typeof obj != \"function\") return false;\n\n    // async function or arrow function\n    if (obj.prototype === undefined)\n        return false;\n\n    // generator function and malformed inheritance\n    if (obj.prototype.constructor !== obj)\n        return false;\n\n    // has own prototype properties\n    if (Object.getOwnPropertyNames(obj.prototype).length >= 2)\n        return true;\n\n    var str = String(obj);\n\n    // ES6 class\n    if (str.slice(0, 5) == \"class\")\n        return true;\n\n    // anonymous function\n    if (/^function\\s*\\(|^function anonymous\\(/.test(str))\n        return false;\n\n    var hasThis = /(call|apply|_classCallCheck)\\(this(, arguments)?\\)|\\bthis(.\\S+|\\[.+?\\])\\s*(=|\\()|=\\s*this[,;]/.test(str);\n\n    // Upper-cased first char of the name and has `this` in the body, or it's\n    // a native class in ES5 style.\n    if (/^function\\s+[A-Z]/.test(str) && (hasThis ||\n        (/\\[native code\\]/.test(str) &&\n            obj.name !== \"BigInt\" && // ES6 BigInt and Symbol is not class\n            obj.name !== \"Symbol\"\n        )\n    )) {\n        return true;\n    }\n\n    // TypeScript anonymous class to ES5 with default export\n    if (hasThis && obj.name === \"default_1\")\n        return true;\n\n    return false;\n}\n\nexports.couldBeClass = couldBeClass;\nexports.default = couldBeClass;","import isVoid from \"./isVoid.ts\";\nimport { couldBeClass as isClass } from \"could-be-class\";\n/**\n * Returns a string representation or the constructor of the value's type.\n * NOTE: this function also returns `'void'` when testing `NaN`.\n */\nexport default function typeOf(target) {\n    if (arguments.length === 0)\n        throw new TypeError(\"1 argument is required, 0 given\");\n    else if (isVoid(target))\n        return \"void\";\n    let type = typeof target;\n    if (type === \"function\") {\n        if (isClass(target)) {\n            return \"class\";\n        }\n        else {\n            return \"function\";\n        }\n    }\n    else if (type === \"object\") {\n        if (Object.prototype.toString.call(target) === \"[object Arguments]\") {\n            return \"arguments\";\n        }\n        else {\n            return target.constructor || Object;\n        }\n    }\n    else {\n        return type;\n    }\n}\n//# sourceMappingURL=typeOf.js.map","import { isArrayLike, isBufferLike, isCollectionLike } from \"is-like\";\nconst BaseEmptyPrimitives = [\"\", NaN, null, void 0];\nconst EmptyPrimitives = [...BaseEmptyPrimitives, 0, false];\nif (typeof BigInt === \"function\")\n    EmptyPrimitives.push(BigInt(\"0\"));\n/**\n * Checks if the value resolves to an empty object or a falsy value.\n */\nexport default function isEmpty(value, deep = false) {\n    return test(value, Boolean(deep), EmptyPrimitives);\n}\nfunction test(value, deep, emptyPrimitives) {\n    if (emptyPrimitives.includes(value))\n        return true;\n    if (typeof value === \"object\") {\n        if (value instanceof RegExp) {\n            return false;\n        }\n        else if (value instanceof Date) {\n            return String(value) === \"Invalid Date\";\n        }\n        else if (value instanceof Error) {\n            return value.message.length === 0;\n        }\n        else if (isBufferLike(value)) {\n            return value.byteLength === 0;\n        }\n        else if (isArrayLike(value, true)) {\n            if (value.length === 0) {\n                return true;\n            }\n            else if (!deep) {\n                return false;\n            }\n            else {\n                for (let i = 0, len = value.length; i < len; ++i) {\n                    if (!test(value[i], deep, BaseEmptyPrimitives)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        else if (isCollectionLike(value, true)) {\n            if (value.size === 0) {\n                return true;\n            }\n            else if (!deep) {\n                return false;\n            }\n            else {\n                if (value instanceof Map) {\n                    for (let v of value.values()) {\n                        if (!test(v, deep, BaseEmptyPrimitives)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                else if (value instanceof Set) {\n                    for (let v of value) {\n                        if (!test(v, deep, BaseEmptyPrimitives)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return false;\n            }\n        }\n        else {\n            let keys = Reflect.ownKeys(value);\n            if (keys.length === 0) {\n                return true;\n            }\n            else if (!deep) {\n                return false;\n            }\n            else {\n                return keys.every(k => test(value[k], deep, BaseEmptyPrimitives));\n            }\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=isEmpty.js.map","/** Returns `true` if the given value is a float number, `false` otherwise. */\nexport function isFloat(value) {\n    return typeof value === \"number\"\n        && !Number.isNaN(value)\n        && (!Number.isFinite(value) || value % 1 !== 0);\n}\n/**\n * Returns `true` if the given value is a numeric value, `false` otherwise. A numeric value is a\n * number, a bigint, or a string that can be converted to a number or bigint.\n */\nexport function isNumeric(value) {\n    const type = typeof value;\n    if (type === \"number\" || type === \"bigint\") {\n        return true;\n    }\n    else if (type === \"string\") {\n        if (!Number.isNaN(value)) {\n            return true;\n        }\n        else {\n            try {\n                BigInt(value);\n                return true;\n            }\n            catch (_a) {\n                return false;\n            }\n        }\n    }\n    return false;\n}\n/** Return `true` if a number is between the given range (inclusive). */\nexport function isBetween(value, [min, max]) {\n    return value >= min && value <= max;\n}\n/** Returns a random integer ranged from `min` to `max`. */\nexport function random(min, max) {\n    return min + Math.floor(Math.random() * (max - min + 1));\n}\n/** Creates a generator that produces sequential numbers from `min` to `max` (inclusive). */\nexport function* sequence(min, max, step = 1, loop = false) {\n    let id = min;\n    while (true) {\n        yield id;\n        if (id >= max) {\n            if (loop) {\n                id = min;\n            }\n            else {\n                break;\n            }\n        }\n        else {\n            id += step;\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","import { isArrayLike, isDictLike } from \"is-like\";\nimport { isBetween } from \"@ayonli/jsext/number\";\nconst truePattern = /^\\s*(true|yes|on)\\s*$/i;\nconst falsePattern = /^\\s*(false|no|off)\\s*$/i;\nconst nullPattern = /^\\s*(null|nil|none|void|undefined)\\s*$/i;\nconst nanPattern = /^\\s*NaN\\s*$/;\nconst infinityPattern = /^\\s*-?Infinity\\s*/;\nconst regexPattern = /^\\s*\\/(.+)\\/([gimuys]*)\\s*$/;\nconst numberInterval = [\n    Number.MIN_SAFE_INTEGER,\n    Number.MAX_SAFE_INTEGER\n];\n/**\n * Casts the target object or its contents to the closest types automatically.\n * This function is useful when reading config from a file or fetching data from\n * the web.\n */\nexport default function ensureType(target) {\n    switch (typeof target) {\n        case \"string\": {\n            let re;\n            if (truePattern.test(target)) {\n                return true;\n            }\n            else if (falsePattern.test(target)) {\n                return false;\n            }\n            else if (nullPattern.test(target)) {\n                return null;\n            }\n            else if (nanPattern.test(target)) {\n                return NaN;\n            }\n            else if (infinityPattern.test(target)) {\n                return Number(target);\n            }\n            else if (re = target.match(regexPattern)) {\n                return new RegExp(re[1], re[2]);\n            }\n            else {\n                let num = Number(target);\n                if (!isNaN(num) &&\n                    isBetween(num, numberInterval) &&\n                    target[0] !== \"+\" // Most likely a telephone number.\n                ) {\n                    return num;\n                }\n                else {\n                    return target;\n                }\n            }\n        }\n        case \"object\": {\n            if (target === null) {\n                return null;\n            }\n            else if (isArrayLike(target, true)) {\n                return ensureArray(target).map(ensureType);\n            }\n            else if (isDictLike(target)) {\n                return Reflect.ownKeys(target).reduce((result, key) => {\n                    result[key] = ensureType(target[key]);\n                    return result;\n                }, {});\n            }\n            else {\n                return target;\n            }\n        }\n        default:\n            return target;\n    }\n}\nexport function ensureArray(value) {\n    return Array.isArray(value) ? value : Array.from(value);\n}\n//# sourceMappingURL=ensureType.js.map","import { isDictLike, isArrayLike, isBufferLike } from \"is-like\";\nimport isVoid from \"./isVoid.ts\";\nexport default function flatObject(obj, depth = 1, flatArray = false) {\n    return flatDeep({}, obj, \"\", 0, depth, flatArray);\n}\nfunction flatDeep(carrier, source, field, depth, maxDepth, flatArray) {\n    let isArr;\n    let isDict;\n    let isContent = !isVoid(field) && field !== \"\";\n    if (depth === maxDepth || (!(isArr = isArrayLike(source, true) && !isBufferLike(source)) &&\n        !(isDict = isDictLike(source)))) {\n        carrier[field] = source;\n    }\n    else if (isDict) {\n        Reflect.ownKeys(source).forEach(key => {\n            let value = source[key];\n            if (typeof key === \"symbol\") {\n                if (depth === 0) { // only allow top-level symbol properties\n                    carrier[key] = value;\n                }\n            }\n            else {\n                flatDeep(carrier, value, isContent ? `${field}.${key}` : key, isContent ? depth + 1 : depth, maxDepth, flatArray);\n            }\n        });\n    }\n    else if (isArr) {\n        if (flatArray) {\n            for (let i = 0, len = source.length; i < len; ++i) {\n                flatDeep(carrier, source[i], isContent ? `${field}.${i}` : String(i), isContent ? depth + 1 : depth, maxDepth, flatArray);\n            }\n        }\n        else {\n            carrier[field] = source;\n        }\n    }\n    return carrier;\n}\n//# sourceMappingURL=flatObject.js.map","import { isBetween as _isBetween } from \"@ayonli/jsext/number\";\n/** @deprecated use `Number.isBetween` from `@ayonli/jsext/number/augment` instead. */\nconst isBetween = _isBetween;\nexport default isBetween;\n//# sourceMappingURL=isBetween.js.map","import { isFloat as _isFloat } from \"@ayonli/jsext/number\";\n/** @deprecated use `Number.isFloat` from `@ayonli/jsext/number/augment` instead. */\nconst isFloat = _isFloat;\nexport default isFloat;\n//# sourceMappingURL=isFloat.js.map","import { isNumeric as _isNumeric } from \"@ayonli/jsext/number\";\n/** @deprecated use `Number.isNumeric` from `@ayonli/jsext/number/augment` instead. */\nconst isNumeric = _isNumeric;\nexport default isNumeric;\n//# sourceMappingURL=isNumeric.js.map","export function hasOwn(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\n;\n/**\n * Returns `true` if the specified object has the indicated method as its own method (in its own\n * prototype). If the method is inherited, or is not in the prototype, or does not exist, this\n * function returns `false`.\n */\nexport function hasOwnMethod(obj, method) {\n    var _a;\n    const proto = Object.getPrototypeOf(obj);\n    if (!proto || !hasOwn(proto, method)) {\n        return false;\n    }\n    return typeof ((_a = Object.getOwnPropertyDescriptor(proto, method)) === null || _a === void 0 ? void 0 : _a.value) === \"function\";\n}\nexport function patch(target, ...sources) {\n    for (const source of sources) {\n        for (const key of Reflect.ownKeys(source)) {\n            if (!hasOwn(target, key) || target[key] === undefined) {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\n;\nexport function pick(obj, keys) {\n    return keys.reduce((result, key) => {\n        if (key in obj && obj[key] !== undefined) {\n            result[key] = obj[key];\n        }\n        return result;\n    }, {});\n}\nexport function omit(obj, keys) {\n    const allKeys = Reflect.ownKeys(obj);\n    const keptKeys = allKeys.filter(key => !keys.includes(key));\n    const result = pick(obj, keptKeys);\n    // special treatment for Error types\n    if (obj instanceof Error) {\n        [\"name\", \"message\", \"cause\"].forEach(key => {\n            if (!keys.includes(key) &&\n                obj[key] !== undefined &&\n                !hasOwn(result, key)) {\n                result[key] = obj[key];\n            }\n        });\n    }\n    return result;\n}\nexport function as(value, type) {\n    if (typeof type !== \"function\") {\n        throw new TypeError(\"type must be a valid constructor\");\n    }\n    let _type;\n    const primitiveMap = {\n        \"string\": String,\n        \"number\": Number,\n        \"bigint\": BigInt,\n        \"boolean\": Boolean,\n        \"symbol\": Symbol\n    };\n    if (value instanceof type) {\n        if ([String, Number, Boolean].includes(type)) {\n            return value.valueOf(); // make sure the primitives are returned.\n        }\n        else {\n            return value;\n        }\n    }\n    else if ((_type = typeof value) && primitiveMap[_type] === type) {\n        return value;\n    }\n    return null;\n}\n/**\n * Returns `true` if the given value is valid. Thee following values are considered invalid:\n *\n * - `undefined`\n * - `null`\n * - `NaN`\n * - `Invalid Date`\n */\nexport function isValid(value) {\n    return value !== undefined\n        && value !== null\n        && !Object.is(value, NaN)\n        && !(value instanceof Date && value.toString() === \"Invalid Date\");\n}\n//# sourceMappingURL=index.js.map","import { hasOwn } from \"@ayonli/jsext/object\";\n/** @deprecated use `Object.hasOwn` from `@ayonli/jsext/object/augment` instead. */\nconst isOwnKey = hasOwn;\nexport default isOwnKey;\n//# sourceMappingURL=isOwnKey.js.map","import { hasOwnMethod } from \"@ayonli/jsext/object\";\n/** @deprecated use `Object.hasOwnMethod` from `@ayonli/jsext/object/augment` instead. */\nconst isOwnMethod = hasOwnMethod;\nexport default isOwnMethod;\n//# sourceMappingURL=isOwnMethod.js.map","if (!Symbol.asyncIterator) {\n    Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\");\n}\n\n/**\n * Checks if the given object is an Iterable (implemented `@@iterator`).\n * @returns {obj is Iterable<any>}\n */\nexport function isIterable(obj) {\n    return obj !== null\n        && obj !== undefined\n        && typeof obj[Symbol.iterator] === \"function\";\n}\n\n/**\n * Checks if the given object is an AsyncIterable (implemented `@@asyncIterator`).\n * @returns {obj is AsyncIterable<any>}\n */\nexport function isAsyncIterable(obj) {\n    return obj !== null\n        && obj !== undefined\n        && typeof obj[Symbol.asyncIterator] === \"function\";\n}\n\n/**\n * Checks if the given object is an IteratorLike (implemented `next`).\n * @returns {obj is { next: Function }}\n */\nexport function isIteratorLike(obj) {\n    // An iterable object has a 'next' method, however including a 'next' method\n    // doesn't ensure the object is an iterator, it is only iterator-like.\n    return typeof obj === \"object\"\n        && obj !== null\n        && typeof obj.next === \"function\";\n}\n\n/**\n * Checks if the given object is an IterableIterator (implemented both\n * `@@iterator` and `next`).\n */\nexport function isIterableIterator(obj) {\n    return isIteratorLike(obj)\n        && typeof obj[Symbol.iterator] === \"function\";\n}\n\n/**\n * Checks if the given object is an AsyncIterableIterator (implemented\n * both `@@asyncIterator` and `next`).\n * @returns {obj is AsyncIterableIterator<any>}\n */\nexport function isAsyncIterableIterator(obj) {\n    return isIteratorLike(obj)\n        && typeof obj[Symbol.asyncIterator] === \"function\";\n}\n\n/**\n * Checks if the given object is a Generator.\n * @returns {obj is Generator}\n */\nexport function isGenerator(obj) {\n    return isIterableIterator(obj)\n        && hasGeneratorSpecials(obj);\n}\n\n/**\n * Checks if the given object is an AsyncGenerator.\n * @returns {obj is AsyncGenerator}\n */\nexport function isAsyncGenerator(obj) {\n    return isAsyncIterableIterator(obj)\n        && hasGeneratorSpecials(obj);\n}\n\nfunction hasGeneratorSpecials(obj) {\n    return typeof obj.return === \"function\"\n        && typeof obj.throw === \"function\";\n}\n","const throttleCaches = new Map();\nexport default function throttle(handler, options) {\n    const key = typeof options === \"number\" ? null : options.for;\n    const duration = typeof options === \"number\" ? options : options.duration;\n    const handleCall = function (cache, ...args) {\n        var _a;\n        if (cache.result && Date.now() < ((_a = cache.expires) !== null && _a !== void 0 ? _a : 0)) {\n            if (cache.result.error) {\n                throw cache.result.error;\n            }\n            else {\n                return cache.result.value;\n            }\n        }\n        try {\n            const returns = handler.call(this, ...args);\n            cache.result = { value: returns };\n            cache.expires = Date.now() + duration;\n            return returns;\n        }\n        catch (error) {\n            cache.result = { error };\n            cache.expires = Date.now() + duration;\n            throw error;\n        }\n    };\n    if (!key) {\n        const cache = { for: null };\n        return function (...args) {\n            return handleCall.call(this, cache, ...args);\n        };\n    }\n    else {\n        let cache = throttleCaches.get(key);\n        if (!cache) {\n            cache = { for: key };\n            throttleCaches.set(key, cache);\n        }\n        return function (...args) {\n            return handleCall.call(this, cache, ...args);\n        };\n    }\n}\n//# sourceMappingURL=throttle.js.map","export class Channel {\n    constructor(capacity = 0) {\n        this.buffer = [];\n        this.state = 1;\n        if (capacity < 0) {\n            throw new RangeError(\"the capacity of a channel must not be negative\");\n        }\n        this.capacity = capacity;\n    }\n    /**\n     * Pushes data to the channel.\n     *\n     * If there is a receiver, the data will be consumed immediately. Otherwise:\n     *\n     * - If this is an non-buffered channel, this function will block until a receiver is\n     *  available and the data is consumed.\n     *\n     * - If this is a buffered channel, then:\n     *      - If the buffer size is within the capacity, the data will be pushed to the buffer.\n     *      - Otherwise, this function will block until there is new room for the data in the\n     *          buffer.\n     */\n    push(data) {\n        if (this.state !== 1) {\n            throw new Error(\"the channel is closed\");\n        }\n        else if (this.sub) {\n            return Promise.resolve(this.sub(null, data));\n        }\n        else if (this.capacity && this.buffer.length < this.capacity) {\n            this.buffer.push(data);\n            return Promise.resolve(undefined);\n        }\n        else {\n            return new Promise(resolve => {\n                this.pub = () => {\n                    if (this.capacity) {\n                        const _data = this.buffer.shift();\n                        this.buffer.push(data);\n                        this.pub = undefined;\n                        resolve();\n                        return _data;\n                    }\n                    else {\n                        this.pub = undefined;\n                        resolve();\n                        return data;\n                    }\n                };\n            });\n        }\n    }\n    /**\n     * Retrieves data from the channel.\n     *\n     * If there isn't data available at the moment, this function will block until new data is\n     * available.\n     *\n     * If the channel is closed, then:\n     *\n     * - If there is error set in the channel, this function throws that error immediately.\n     * - Otherwise, this function returns `undefined` immediately.\n     */\n    pop() {\n        if (this.buffer.length) {\n            return Promise.resolve(this.buffer.shift());\n        }\n        else if (this.pub) {\n            return Promise.resolve(this.pub());\n        }\n        else if (this.state === 0) {\n            return Promise.resolve(undefined);\n        }\n        else if (this.error) {\n            // Error can only be consumed once, after that, that closure will be complete.\n            const { error } = this;\n            this.state = 0;\n            this.error = undefined;\n            return Promise.reject(error);\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                this.sub = (err, data) => {\n                    this.sub = undefined;\n                    err ? reject(err) : resolve(data);\n                };\n            });\n        }\n    }\n    /**\n     * Closes the channel. If `err` is supplied, it will be captured by the receiver.\n     *\n     * No more data shall be sent once the channel is closed.\n     *\n     * Explicitly closing the channel is not required, if the channel is no longer used, it\n     * will be automatically released by the GC. However, if the channel is used in a\n     * `for await...of...` loop, closing the channel will allow the loop to break automatically.\n     */\n    close(err = null) {\n        this.state = 2;\n        this.error = err;\n        // Delay the closure till the next event loop so that `sub` can be bound in the\n        // `for await...of...` loop and the last message can be delivered.\n        setTimeout(() => {\n            var _a;\n            this.state = 0;\n            (_a = this.sub) === null || _a === void 0 ? void 0 : _a.call(this, err, undefined);\n        });\n    }\n    [Symbol.asyncIterator]() {\n        const channel = this;\n        return {\n            async next() {\n                const bufSize = channel.buffer.length;\n                const value = await channel.pop();\n                return { value: value, done: channel.state === 0 && !bufSize };\n            }\n        };\n    }\n}\n/**\n * Inspired by Golang, cerates a channel that can be used to transfer data within the program.\n *\n * Unlike `EventEmitter` or `EventTarget`, `Channel` guarantees the data will always be delivered,\n * even if there is no receiver at the moment.\n *\n * If `capacity` is not set, a non-buffered channel will be created. For a non-buffered channel,\n * the sender and receiver must be present at the same time (theoretically), otherwise, the\n * channel will block (non-IO aspect).\n *\n * If `capacity` is set, a buffered channel will be created. For a buffered channel, data will\n * be queued in the buffer first and then consumed by the receiver in FIFO order. Once the\n * buffer size reaches the capacity limit, no more data will be sent unless there is new room\n * available.\n *\n * It is possible to set the `capacity` to `Infinity` to allow the channel to never block and\n * behave like a message queue.\n *\n * @example\n * ```ts\n * const channel = chan<number>();\n *\n * (async () => {\n *     await channel.push(123);\n * })();\n *\n * const num = await channel.pop();\n * console.log(num);\n * // output:\n * // 123\n * ```\n *\n * @example\n * ```ts\n * const channel = chan<number>(3);\n *\n * await channel.push(123);\n * await channel.push(456);\n * await channel.push(789);\n *\n * const num1 = await channel.pop();\n * const num2 = await channel.pop();\n * const num3 = await channel.pop();\n *\n * console.log(num1);\n * console.log(num2);\n * console.log(num3);\n * // output:\n * // 123\n * // 456\n * // 789\n * ```\n *\n * @example\n * ```ts\n * const channel = chan<number>();\n *\n * (async () => {\n *     for (const num of Number.sequence(1, 5)) {\n *         await channel.push(num);\n *     }\n *\n *     channel.close();\n * })();\n *\n * for await (const num of channel) {\n *     console.log(num);\n * }\n * // output:\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * ```\n */\nexport default function chan(capacity = 0) {\n    return new Channel(capacity);\n}\n//# sourceMappingURL=chan.js.map","var _a;\nimport { sequence } from \"./number/index.ts\";\nimport chan from \"./chan.ts\";\nconst isNode = typeof process === \"object\" && !!((_a = process.versions) === null || _a === void 0 ? void 0 : _a.node);\n/**\n * The maximum number of workers allowed to exist at the same time.\n *\n * The primary purpose of the workers is not mean to run tasks in parallel, but run them in separate\n * from the main thread, so that aborting tasks can be achieved by terminating the worker thread and\n * it will not affect the main thread.\n *\n * That said, the worker thread can still be used to achieve parallelism, but it should be noticed\n * that only the numbers of tasks that equals to the CPU core numbers will be run at the same time.\n */\nconst maxWorkerNum = 16;\nconst workerIdCounter = sequence(1, Number.MAX_SAFE_INTEGER, 1, true);\nlet workerPool = [];\n// The worker consumer queue is nothing but a callback list, once a worker is available, the runner\n// pop a consumer and run the callback, which will retry gaining the worker and retry the task.\nconst workerConsumerQueue = [];\n/**\n * Runs a `script` in a worker thread or child process that can be aborted during runtime.\n *\n * In Node.js and Bun, the `script` can be either a CommonJS module or an ES module, and is relative\n * to the current working directory if not absolute.\n *\n * In browser and Deno, the `script` can only be an ES module, and is relative to the current URL\n * (or working directory for Deno) if not absolute.\n *\n * @example\n * ```ts\n * const job1 = await run(\"./job-example.mjs\", [\"World\"]);\n * console.log(await job1.result()); // Hello, World\n * ```\n *\n * @example\n * ```ts\n * const job2 = await run<string, [string[]]>(\"./job-example.mjs\", [[\"foo\", \"bar\"]], {\n *     fn: \"sequence\",\n * });\n * for await (const word of job2.iterate()) {\n *     console.log(word);\n * }\n * // output:\n * // foo\n * // bar\n * ```\n *\n * @example\n * ```ts\n * const job3 = await run<string, [string]>(\"./job-example.mjs\", [\"foobar\"], {\n *    fn: \"takeTooLong\",\n * });\n * await job3.abort();\n * const [err, res] = await _try(job3.result());\n * console.assert(err === null);\n * console.assert(res === undefined);\n * ```\n */\nexport default async function run(script, args = undefined, options = undefined) {\n    var _a, _b;\n    const msg = {\n        type: \"ffi\",\n        script,\n        baseUrl: \"\",\n        fn: (options === null || options === void 0 ? void 0 : options.fn) || \"default\",\n        args: args !== null && args !== void 0 ? args : [],\n    };\n    if (typeof Deno === \"object\") {\n        msg.baseUrl = \"file://\" + Deno.cwd() + \"/\";\n    }\n    else if (isNode) {\n        msg.baseUrl = \"file://\" + process.cwd() + \"/\";\n    }\n    else if (typeof location === \"object\") {\n        msg.baseUrl = location.href;\n    }\n    let error = null;\n    let result;\n    let resolver;\n    let channel = undefined;\n    let workerId;\n    let poolRecord;\n    let release;\n    let terminate = () => Promise.resolve(void 0);\n    const timeout = (options === null || options === void 0 ? void 0 : options.timeout) ? setTimeout(() => {\n        const err = new Error(`operation timeout after ${options.timeout}ms`);\n        if (resolver) {\n            resolver.reject(err);\n        }\n        else {\n            error = err;\n        }\n        terminate();\n    }, options.timeout) : null;\n    const handleMessage = (msg) => {\n        var _a;\n        if (msg && typeof msg === \"object\" && typeof msg.type === \"string\") {\n            if (msg.type === \"error\") {\n                return handleError(msg.error);\n            }\n            else if (msg.type === \"return\") {\n                if (options === null || options === void 0 ? void 0 : options.keepAlive) {\n                    // Release before resolve.\n                    release === null || release === void 0 ? void 0 : release();\n                    if (workerConsumerQueue.length) {\n                        // Queued consumer now has chance to gain the worker.\n                        (_a = workerConsumerQueue.shift()) === null || _a === void 0 ? void 0 : _a();\n                    }\n                }\n                else {\n                    terminate();\n                }\n                if (resolver) {\n                    resolver.resolve(msg.value);\n                }\n                else {\n                    result = { value: msg.value };\n                }\n            }\n            else if (msg.type === \"yield\") {\n                if (msg.done) {\n                    // The final message of yield event is the return value.\n                    handleMessage({ type: \"return\", value: msg.value });\n                }\n                else {\n                    channel === null || channel === void 0 ? void 0 : channel.push(msg.value);\n                }\n            }\n        }\n    };\n    const handleError = (err) => {\n        if (resolver) {\n            resolver.reject(err);\n        }\n        else if (channel) {\n            channel.close(err);\n        }\n        else {\n            error = err;\n        }\n    };\n    const handleExit = () => {\n        var _a;\n        if (poolRecord) {\n            // Clean the pool before resolve.\n            workerPool = workerPool.filter(record => record !== poolRecord);\n            if (workerConsumerQueue.length) {\n                // Queued consumer now has chance to create new worker.\n                (_a = workerConsumerQueue.shift()) === null || _a === void 0 ? void 0 : _a();\n            }\n        }\n        if (resolver) {\n            resolver.resolve(void 0);\n        }\n        else if (channel) {\n            channel.close();\n        }\n        else if (!error && !result) {\n            result = { value: void 0 };\n        }\n    };\n    if (isNode) {\n        let entry = options === null || options === void 0 ? void 0 : options.workerEntry;\n        if (!entry) {\n            const path = await import(\"path\");\n            const { fileURLToPath } = await import(\"url\");\n            const dirname = path.dirname(fileURLToPath(import.meta.url));\n            if ([\"cjs\", \"esm\"].includes(path.basename(dirname))) { // compiled\n                entry = path.join(path.dirname(dirname), \"bundle\", \"worker.mjs\");\n            }\n            else {\n                entry = path.join(dirname, \"worker.mjs\");\n            }\n        }\n        if ((options === null || options === void 0 ? void 0 : options.adapter) === \"child_process\") {\n            let worker;\n            let ok = true;\n            poolRecord = workerPool.find(item => {\n                return item.adapter === \"child_process\" && !item.busy;\n            });\n            if (poolRecord) {\n                worker = poolRecord.worker;\n                workerId = poolRecord.workerId;\n                poolRecord.busy = true;\n            }\n            else if (workerPool.length < maxWorkerNum) {\n                const { fork } = await import(\"child_process\");\n                const isPrior14 = parseInt(process.version.slice(1)) < 14;\n                worker = fork(entry, {\n                    stdio: \"inherit\",\n                    serialization: isPrior14 ? \"advanced\" : \"json\",\n                });\n                workerId = worker.pid;\n                ok = await new Promise((resolve) => {\n                    worker.once(\"exit\", () => {\n                        if (error) {\n                            // The child process took too long to start and cause timeout error.\n                            resolve(false);\n                        }\n                    });\n                    worker.once(\"message\", () => {\n                        worker.removeAllListeners(\"exit\");\n                        resolve(true);\n                    });\n                });\n                // Fill the worker pool regardless the current call should keep-alive or not,\n                // this will make sure that the total number of workers will not exceed the\n                // maxWorkerNum. If the the call doesn't keep-alive the worker, it will be\n                // cleaned after the call.\n                ok && workerPool.push(poolRecord = {\n                    workerId,\n                    worker,\n                    adapter: \"child_process\",\n                    busy: true,\n                });\n            }\n            else {\n                // Put the current call in the consumer queue if there are no workers available,\n                // once an existing call finishes, the queue will pop the its head consumer and\n                // retry.\n                return new Promise((resolve) => {\n                    workerConsumerQueue.push(resolve);\n                }).then(() => run(script, args, options));\n            }\n            release = () => {\n                // Remove the event listener so that later calls will not mess up.\n                worker.off(\"message\", handleMessage);\n                poolRecord && (poolRecord.busy = false);\n            };\n            terminate = () => Promise.resolve(void worker.kill(1));\n            if (ok) {\n                worker.send(msg);\n                worker.on(\"message\", handleMessage);\n                worker.once(\"error\", handleError);\n                worker.once(\"exit\", handleExit);\n            }\n        }\n        else {\n            let worker;\n            let ok = true;\n            poolRecord = workerPool.find(item => {\n                return item.adapter === \"worker_threads\" && !item.busy;\n            });\n            if (poolRecord) {\n                worker = poolRecord.worker;\n                workerId = poolRecord.workerId;\n                poolRecord.busy = true;\n            }\n            else if (workerPool.length < maxWorkerNum) {\n                const { Worker } = await import(\"worker_threads\");\n                worker = new Worker(entry);\n                // `threadId` may not exist in Bun.\n                workerId = (_a = worker.threadId) !== null && _a !== void 0 ? _a : workerIdCounter.next().value;\n                ok = await new Promise((resolve) => {\n                    worker.once(\"exit\", () => {\n                        if (error) {\n                            // The child process took too long to start and cause timeout error.\n                            resolve(false);\n                        }\n                    });\n                    worker.once(\"online\", () => {\n                        worker.removeAllListeners(\"exit\");\n                        resolve(true);\n                    });\n                });\n                ok && workerPool.push(poolRecord = {\n                    workerId,\n                    worker,\n                    adapter: \"worker_threads\",\n                    busy: true,\n                });\n            }\n            else {\n                return new Promise((resolve) => {\n                    workerConsumerQueue.push(resolve);\n                }).then(() => run(script, args, options));\n            }\n            release = () => {\n                worker.off(\"message\", handleMessage);\n                poolRecord && (poolRecord.busy = false);\n            };\n            terminate = async () => void (await worker.terminate());\n            if (ok) {\n                worker.postMessage(msg);\n                worker.on(\"message\", handleMessage);\n                worker.once(\"error\", handleError);\n                worker.once(\"messageerror\", handleError);\n                worker.once(\"exit\", handleExit);\n            }\n        }\n    }\n    else {\n        let worker;\n        poolRecord = workerPool.find(item => {\n            return item.adapter === \"worker_threads\" && !item.busy;\n        });\n        if (poolRecord) {\n            worker = poolRecord.worker;\n            workerId = poolRecord.workerId;\n            poolRecord.busy = true;\n        }\n        else if (workerPool.length < maxWorkerNum) {\n            let url;\n            if (typeof Deno === \"object\") {\n                // Deno can load the module regardless of MINE type.\n                url = [\n                    ...(import.meta.url.split(\"/\").slice(0, -1)),\n                    \"worker-web.mjs\"\n                ].join(\"/\");\n            }\n            else {\n                const _url = (options === null || options === void 0 ? void 0 : options.workerEntry)\n                    || \"https://raw.githubusercontent.com/ayonli/jsext/main/bundle/worker-web.mjs\";\n                const res = await fetch(_url);\n                let blob;\n                if ((_b = res.headers.get(\"content-type\")) === null || _b === void 0 ? void 0 : _b.startsWith(\"application/javascript\")) {\n                    blob = await res.blob();\n                }\n                else {\n                    const buf = await res.arrayBuffer();\n                    blob = new Blob([new Uint8Array(buf)], {\n                        type: \"application/javascript\",\n                    });\n                }\n                url = URL.createObjectURL(blob);\n            }\n            worker = new Worker(url, { type: \"module\" });\n            workerId = workerIdCounter.next().value;\n            workerPool.push(poolRecord = {\n                workerId,\n                worker,\n                adapter: \"worker_threads\",\n                busy: true,\n            });\n        }\n        else {\n            return new Promise((resolve) => {\n                workerConsumerQueue.push(resolve);\n            }).then(() => run(script, args, options));\n        }\n        release = () => {\n            worker.onmessage = null;\n            poolRecord && (poolRecord.busy = false);\n        };\n        terminate = async () => {\n            await Promise.resolve(worker.terminate());\n            handleExit();\n        };\n        worker.postMessage(msg);\n        worker.onmessage = (ev) => handleMessage(ev.data);\n        worker.onerror = (ev) => handleMessage(ev.error || new Error(ev.message));\n        worker.onmessageerror = () => {\n            handleError(new Error(\"unable to deserialize the message\"));\n        };\n    }\n    return {\n        workerId,\n        async abort() {\n            timeout && clearTimeout(timeout);\n            await terminate();\n        },\n        async result() {\n            return await new Promise((resolve, reject) => {\n                if (error) {\n                    reject(error);\n                }\n                else if (result) {\n                    resolve(result.value);\n                }\n                else {\n                    resolver = { resolve, reject };\n                }\n            });\n        },\n        iterate() {\n            if (resolver) {\n                throw new Error(\"result() has been called\");\n            }\n            else if (result) {\n                throw new TypeError(\"the response is not iterable\");\n            }\n            channel = chan(Infinity);\n            return {\n                [Symbol.asyncIterator]: channel[Symbol.asyncIterator].bind(channel),\n            };\n        },\n    };\n}\n//# sourceMappingURL=run.js.map","import _try from \"./try.ts\";\nimport func from \"./func.ts\";\nimport wrap from \"./wrap.ts\";\nimport throttle from \"./throttle.ts\";\nimport mixins from \"./mixins.ts\";\nimport isSubclassOf from \"./isSubclassOf.ts\";\nimport chan, { Channel } from \"./chan.ts\";\nimport read from \"./read.ts\";\nimport run from \"./run.ts\";\nimport example from \"./example.ts\";\nexport { Channel };\nexport const AsyncFunction = (async function () { }).constructor;\nexport const AsyncGeneratorFunction = (async function* () { }).constructor;\n/**\n * The entry of jsext main functions.\n */\nconst jsext = {\n    try: _try,\n    func,\n    wrap,\n    throttle,\n    mixins,\n    isSubclassOf,\n    chan,\n    read,\n    run,\n    example,\n};\nexport default jsext;\nexport { _try, func, wrap, throttle, mixins, isSubclassOf, chan, read, run, example, };\n//# sourceMappingURL=index.js.map","/**\n * Wraps a function inside another function and returns a new function that copies the original\n * function's name and other properties.\n *\n * @example\n * ```ts\n * function log(text: string) {\n *     console.log(text);\n * }\n *\n * const show = wrap(log, function (fn, text) {\n *     return fn.call(this, new Date().toISOString() + \" \" + text);\n * });\n *\n * console.log(show.name); // log\n * console.log(show.length); // 1\n * console.assert(show.toString() === log.toString());\n * ```\n */\nexport default function wrap(fn, wrapper) {\n    const wrapped = function (...args) {\n        return wrapper.call(this, fn, ...args);\n    };\n    Object.defineProperty(wrapped, \"name\", Object.getOwnPropertyDescriptor(fn, \"name\"));\n    Object.defineProperty(wrapped, \"length\", Object.getOwnPropertyDescriptor(fn, \"length\"));\n    Object.defineProperty(wrapped, \"toString\", {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: fn.toString.bind(fn),\n    });\n    return wrapped;\n}\n//# sourceMappingURL=wrap.js.map","import jsext from \"@ayonli/jsext\";\n/** @deprecated use `jsext.jsSubclassOf` from `@ayonli/jsext` instead. */\nconst isSubClassOf = jsext.isSubclassOf;\nexport default isSubClassOf;\n//# sourceMappingURL=isSubClassOf.js.map","/**\n * Checks if a class is a subclass of another class.\n *\n * @example\n * ```ts\n * class Moment extends Date {}\n *\n * console.assert(isSubclassOf(Moment, Date));\n * console.assert(isSubclassOf(Moment, Object)); // all classes are subclasses of Object\n * ```\n */\nexport default function isSubclassOf(ctor1, ctor2) {\n    return typeof ctor1 === \"function\"\n        && typeof ctor2 === \"function\"\n        && ctor1.prototype instanceof ctor2;\n}\n//# sourceMappingURL=isSubclassOf.js.map","import { isArrayLike, isBufferLike } from \"is-like\";\nimport { isValid } from \"@ayonli/jsext/object\";\nimport isEmpty from \"./isEmpty.ts\";\n/**\n * Creates an object composed with only the valid properties and values.\n * @param omitEmptyObjects If set, empty properties of type `object` will be\n *  removed as well.\n * @param omitEmptyStrings If set, empty properties of type `string` will be\n *  removed as well.\n */\nexport default function omitInvalid(target, deep = false, omitEmptyObjects = false, omitEmptyStrings = false) {\n    return doOmit(target, deep, omitEmptyObjects, omitEmptyStrings, 0);\n}\nexport function doOmit(target, deep, omitEmptyObjects, omitEmptyStrings, depth) {\n    if (typeof target === \"string\") {\n        return omitEmptyStrings && target.trim() === \"\"\n            ? (depth > 0 ? void 0 : \"\")\n            : target;\n    }\n    else if (target === null\n        || typeof target !== \"object\"\n        || target instanceof Date\n        || target instanceof Error\n        || target instanceof RegExp\n        || isBufferLike(target)) {\n        return target;\n    }\n    else if (omitEmptyObjects && isEmpty(target)) {\n        return depth > 0 ? void 0 : (isArrayLike(target, true) ? [] : {});\n    }\n    if (isArrayLike(target, true)) {\n        let arr = [];\n        for (let i = 0, len = target.length; i < len; ++i) {\n            let value = target[i];\n            if (isValid(value)) {\n                if (deep) {\n                    value = doOmit(value, deep, omitEmptyObjects, omitEmptyStrings, depth + 1);\n                    !isValid(value) || arr.push(value);\n                }\n                else {\n                    arr.push(value);\n                }\n            }\n        }\n        if (depth > 0 && omitEmptyObjects && isEmpty(arr)) {\n            return void 0;\n        }\n        else {\n            return arr;\n        }\n    }\n    else {\n        let obj = Reflect.ownKeys(target).reduce((obj, key) => {\n            let value = target[key];\n            if (isValid(value)) {\n                if (deep) {\n                    value = doOmit(value, deep, omitEmptyObjects, omitEmptyStrings, depth + 1);\n                    !isValid(value) || (obj[key] = value);\n                }\n                else {\n                    obj[key] = value;\n                }\n            }\n            return obj;\n        }, {});\n        if (depth > 0 && omitEmptyObjects && isEmpty(obj)) {\n            return void 0;\n        }\n        else {\n            return obj;\n        }\n    }\n}\n//# sourceMappingURL=omitInvalid.js.map","import omitInvalid from \"./omitInvalid.ts\";\n/**\n * @deprecated use `omitInvalid` instead\n */\nconst omitVoid = omitInvalid;\nexport default omitVoid;\n//# sourceMappingURL=omitVoid.js.map","import { isDictLike } from \"is-like\";\nimport { isValid } from \"@ayonli/jsext/object\";\nimport isEmpty from \"./isEmpty.ts\";\n/**\n * Patches the differences onto the `origin` object from the `input` object. If\n * a property exists in both objects and the values are not equal, the `input`\n * one will be taken. However, those properties that are only presents in the\n * `origin` object will remain untouched.\n *\n * NOTE: This function mutates the `origin` object and returns the patched\n * differences, when patching, any void value in the `input` object will be\n * ignored.\n *\n * This function is very useful, for example, a client issued a patch of the\n * resource and the server wants to know what properties has been modified by\n * this update so that it can perform some extra operations to provide a better\n * user experience.\n */\nexport default function patch(origin, input, deep = false, ignoreEmptyStrings = false) {\n    return doPatch(origin, input, deep, ignoreEmptyStrings, false);\n}\nfunction doPatch(origin, input, deep, ignoreEmptyStrings, isChildNode) {\n    if (isDictLike(origin) && isDictLike(input)) {\n        let keys = Reflect.ownKeys(input);\n        let result = {};\n        keys.forEach(key => {\n            if (origin[key] !== input[key] &&\n                isValid(input[key]) && // ignore invalid values\n                (!ignoreEmptyStrings || input[key] !== \"\")) {\n                if (deep && isDictLike(origin[key]) && isDictLike(input[key])) {\n                    let _result = doPatch(origin[key], input[key], deep, ignoreEmptyStrings, true);\n                    if (!isEmpty(_result)) {\n                        result[key] = _result;\n                        Object.assign(origin[key], input[key]);\n                    }\n                }\n                else {\n                    result[key] = origin[key] = input[key];\n                }\n            }\n        });\n        return result;\n    }\n    else if (isChildNode) {\n        return input;\n    }\n    else {\n        return {};\n    }\n}\n//# sourceMappingURL=patch.js.map","import { random } from \"@ayonli/jsext/number\";\n/** @deprecated use `Number.random` from `@ayonli/jsext/number/augment` instead. */\nconst rand = random;\nexport default rand;\n//# sourceMappingURL=rand.js.map","import { sleep as _sleep } from \"@ayonli/jsext/promise\";\n/** @deprecated use `Promise.sleep` from `@ayonli/jsext/promise/augment` instead. */\nconst sleep = _sleep;\nexport default sleep;\n//# sourceMappingURL=sleep.js.map","/** Try to resolve a promise with a timeout limit. */\nexport async function timeout(value, ms) {\n    const result = await Promise.race([\n        value,\n        new Promise((_, reject) => setTimeout(() => {\n            reject(new Error(`operation timeout after ${ms}ms`));\n        }, ms))\n    ]);\n    return result;\n}\n/** Resolves a promise only after the given duration. */\nexport async function after(value, ms) {\n    const [result] = await Promise.allSettled([\n        value,\n        new Promise(resolve => setTimeout(resolve, ms))\n    ]);\n    if (result.status === \"fulfilled\") {\n        return result.value;\n    }\n    else {\n        throw result.reason;\n    }\n}\n/** Blocks the context for a given time. */\nexport async function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n/** Blocks the context until the test is passed. */\nexport async function until(test) {\n    if (typeof globalThis.setImmediate === \"undefined\") {\n        // @ts-ignore\n        globalThis.setImmediate = (cb) => setTimeout(cb, 0);\n    }\n    do {\n        await new Promise(globalThis.setImmediate);\n    } while ((await test()) == false);\n}\n//# sourceMappingURL=index.js.map","import { isArrayLike, isDictLike } from \"is-like\";\nimport { ensureArray } from \"./ensureType.ts\";\nexport default function sort(target, method = void 0) {\n    if (isArrayLike(target, true)) {\n        let arr = ensureArray(target);\n        let compare = method;\n        // If the compare function is omitted and all the elements are numbers\n        // (or of bigint), sort them by their values.\n        if (!compare && (onlyNumbers(arr) || onlyNumbers(arr, \"bigint\"))) {\n            compare = (a, b) => a - b;\n        }\n        if (shouldUseNativeSort(arr)) {\n            return arr.sort(compare);\n        }\n        // Emulate stable sort.\n        // Reference: http://blog.vjeux.com/2010/javascript/javascript-sorting-table.html\n        return arr\n            .map((value, index) => ({ value, index }))\n            .sort((a, b) => compare(a.value, b.value) || a.index - b.index)\n            .map(({ value }) => value);\n    }\n    else if (isDictLike(target)) {\n        let deep = Boolean(method);\n        let keys = [\n            ...sort(Object.getOwnPropertyNames(target)),\n            ...Object.getOwnPropertySymbols(target)\n        ];\n        return keys.reduce((result, key) => {\n            let value = target[key];\n            if (deep) {\n                if (isArrayLike(value, true)) {\n                    value = ensureArray(value).map(item => {\n                        return isDictLike(item) ? sort(item, deep) : item;\n                    });\n                }\n                else if (isDictLike(value)) {\n                    value = sort(value, deep);\n                }\n            }\n            result[key] = value;\n            return result;\n        }, {});\n    }\n    else {\n        if (typeof method === \"function\") {\n            throw new TypeError(\"The target to sort is not an array\");\n        }\n        else if (typeof method === \"boolean\") {\n            throw new TypeError(\"The target to sort is not a pure object\");\n        }\n        else {\n            throw new TypeError(\"The target to sort is not an array or a pure object\");\n        }\n    }\n}\nfunction onlyNumbers(arr, type = \"number\") {\n    return arr.every(ele => typeof ele === type);\n}\nfunction shouldUseNativeSort(arr) {\n    if (typeof process === \"object\" && typeof process.versions === \"object\") {\n        return arr.length <= 10\n            || parseFloat(process.versions.v8 || \"0\") >= 7.0;\n    }\n    else if (typeof Deno === \"object\") {\n        return true;\n    }\n    else if (typeof navigator === \"object\"\n        && typeof navigator.userAgent === \"string\") {\n        let match = navigator.userAgent.match(/(Chrome|Firefox|Safari|Edge|OPR)\\/(\\d+)/);\n        if (match) {\n            let name = match[1];\n            let version = parseFloat(match[2]);\n            if ((name === \"Edge\" && arr.length <= 512) ||\n                (name === \"Chrome\" && (version >= 70) || arr.length <= 10) ||\n                (name === \"Firefox\" && version >= 3) ||\n                (name === \"Safari\" && version >= 10.1) ||\n                (name === \"OPR\" && version >= 54)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=sort.js.map","import { isArrayLike, isBufferLike, isCollectionLike } from \"is-like\";\nfunction checkNumberArgument(name, value) {\n    if (typeof value !== \"number\") {\n        throw new TypeError(`argument '${name}' must be a number`);\n    }\n    else if (value < 1) {\n        throw new RangeError(`argument '${name}' must be 1 or higher`);\n    }\n}\nfunction splitArrayLike(arr, length, total = void 0) {\n    let result = [];\n    for (let i = 0, j = (total || arr.length); i < j; i += length) {\n        if (typeof arr.slice === \"function\") {\n            result.push(arr.slice(i, i + length));\n        }\n        else {\n            result.push(Array.prototype.slice.call(arr, i, i + length));\n        }\n    }\n    return result;\n}\nfunction splitBuffer(buf, sep) {\n    let result = [];\n    let offset = 0;\n    let length = sep.length;\n    let total = buf.byteLength;\n    while (offset < total) {\n        let index = buf.indexOf(sep, offset);\n        if (index !== -1) {\n            result.push(buf.slice(offset, index));\n            offset = index + length;\n        }\n        else {\n            result.push(buf.slice(offset));\n            offset = total;\n        }\n    }\n    return result;\n}\nfunction splitObject(obj, size) {\n    let proto = Object.getPrototypeOf(obj);\n    let keyChunks = splitArrayLike(Object.keys(obj), size);\n    let result = [];\n    for (let keys of keyChunks) {\n        let chunk = Object.create(proto);\n        result.push(chunk);\n        for (let key of keys) {\n            chunk[key] = obj[key];\n        }\n    }\n    return result;\n}\nfunction splitNumber(num, step) {\n    let result = [];\n    let offset = 0;\n    while ((offset += step) <= num) {\n        result.push(offset);\n    }\n    if (num > offset - step) {\n        result.push(num);\n    }\n    return result;\n}\nexport default function split(obj, sep) {\n    if (arguments.length < 2) {\n        throw new SyntaxError(`2 arguments required, received ${arguments.length}`);\n    }\n    else if (typeof obj === \"string\") {\n        if (typeof sep === \"string\" || sep instanceof RegExp) {\n            return obj.split(sep);\n        }\n        else {\n            checkNumberArgument(\"length\", sep);\n            return splitArrayLike(obj, sep);\n        }\n    }\n    else if (typeof obj === \"number\") {\n        checkNumberArgument(\"step\", sep);\n        return splitNumber(obj, sep);\n    }\n    else if (typeof Buffer === \"function\"\n        && Buffer.isBuffer(obj)\n        && (typeof sep === \"string\" || Buffer.isBuffer(sep))) {\n        return splitBuffer(obj, sep);\n    }\n    else if (isBufferLike(obj)) {\n        checkNumberArgument(\"byteLength\", sep);\n        return splitArrayLike(obj, sep, obj.byteLength);\n    }\n    else if (isArrayLike(obj, true)) {\n        checkNumberArgument(\"length\", sep);\n        return splitArrayLike(obj, sep);\n    }\n    else if (isCollectionLike(obj)) {\n        let ctor = obj[\"constructor\"];\n        checkNumberArgument(\"size\", sep);\n        return splitArrayLike([...obj], sep).map(list => new ctor(list));\n    }\n    else if (typeof obj === \"object\" && obj !== null) {\n        checkNumberArgument(\"size\", sep);\n        return splitObject(obj, sep);\n    }\n    else {\n        throw new TypeError(\"argument 'obj' must be a string, a number or an object\");\n    }\n}\n//# sourceMappingURL=split.js.map","import { as } from \"@ayonli/jsext/object\";\n/** @deprecated use `Object.as` from `@ayonli/jsext/object/augment` instead. */\nconst typeAs = as;\nexport default typeAs;\n//# sourceMappingURL=typeAs.js.map","import { until as _until } from \"@ayonli/jsext/promise\";\n/** @deprecated use `Promise.until` from `@ayonli/jsext/promise/augment` instead. */\nconst until = _until;\nexport default until;\n//# sourceMappingURL=until.js.map","import isEmpty from \"./isEmpty.ts\";\n// @ts-ignore\nif (typeof setImmediate === \"undefined\") {\n    // compatible with browsers\n    var setImmediate = (cb) => setTimeout(cb, 0);\n}\nexport default useThrottle;\n/**\n * Uses throttle strategy on the given resource and returns a throttle function,\n * if a subsequent call happens within the `interval` time, the previous result\n * will be returned and the current `handle` function will not be invoked.\n *\n * If `backgroundUpdate` is set, when reaching the `interval` time, the `handle`\n * function will be called in background and updates the result the when it's\n * done, the current call and any calls before the update will return the\n * previous result instead.\n *\n * NOTE: this function only creates the throttle function once and uses\n * `interval` only once, any later calls on the same `resource` will return the\n * initial throttle function.\n *\n * @deprecated this implementation is too complicated and redundant, use\n *  `jsext.throttle` from `@ayonli/jsext` instead.\n */\nfunction useThrottle(resource, interval, backgroundUpdate = false) {\n    if (interval < 1) {\n        throw new RangeError(\"The 'interval' time for throttle must not be smaller than 1\");\n    }\n    else if (!useThrottle.gcTimer) {\n        let { gcInterval, tasks: jobs } = useThrottle;\n        useThrottle.gcTimer = setInterval(() => {\n            let now = Date.now();\n            jobs.forEach(({ interval, lastActive }, key) => {\n                if (now - lastActive > Math.max(interval + 5, gcInterval)) {\n                    jobs.delete(key);\n                }\n            });\n        }, gcInterval);\n        if (typeof useThrottle.gcTimer.unref === \"function\") {\n            useThrottle.gcTimer.unref();\n        }\n    }\n    let task = useThrottle.tasks.get(resource);\n    if (!task) {\n        useThrottle.tasks.set(resource, task = createThrottleTask(interval, backgroundUpdate));\n    }\n    return task.func;\n}\n(function (useThrottle) {\n    useThrottle.gcInterval = 30000;\n    useThrottle.gcTimer = void 0;\n    useThrottle.tasks = new Map();\n})(useThrottle || (useThrottle = {}));\nfunction createThrottleTask(interval, backgroundUpdate = false) {\n    let task = {\n        interval,\n        lastActive: 0,\n        cache: void 0,\n        queue: new Set(),\n        func: void 0,\n        daemon: null,\n    };\n    async function throttle(handle, ...args) {\n        if (backgroundUpdate && !this.daemon) {\n            this.daemon = setInterval(() => { var _a; return (_a = this.func) === null || _a === void 0 ? void 0 : _a.call(this, handle, ...args); }, interval);\n            if (typeof this.daemon.unref === \"function\") {\n                this.daemon.unref();\n            }\n        }\n        let now = Date.now();\n        if ((now - this.lastActive) >= interval) {\n            this.lastActive = now;\n            if (backgroundUpdate && this.cache) {\n                Promise.resolve(handle(...args)).then(result => {\n                    this.cache = { value: result, error: null };\n                }).catch(err => {\n                    this.cache = { value: void 0, error: err };\n                });\n                if (this.cache.error)\n                    throw this.cache.error;\n                else\n                    return this.cache.value;\n            }\n            else {\n                // Clear cache before dispatching the new job.\n                this.cache = void 0;\n                let result;\n                let error;\n                try {\n                    result = await handle(...args);\n                    this.cache = { value: result, error: null };\n                }\n                catch (err) {\n                    this.cache = { value: void 0, error: error = err };\n                }\n                // Resolve or reject subsequent jobs once the result is ready,\n                // and make the procedure asynchronous so that they will be\n                // performed after the current job.\n                setImmediate(() => {\n                    if (!isEmpty(this.queue)) {\n                        this.queue.forEach((job) => {\n                            error ? job.reject(error) : job.resolve(result);\n                            this.queue.delete(job);\n                        });\n                    }\n                });\n                if (error)\n                    throw error;\n                else\n                    return result;\n            }\n        }\n        else if (this.cache) {\n            if (this.cache.error)\n                throw this.cache.error;\n            else\n                return this.cache.value;\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                this.queue.add({ resolve, reject });\n            });\n        }\n    }\n    task.func = throttle.bind(task);\n    return task;\n}\n//# sourceMappingURL=useThrottle.js.map","import jsext from \"@ayonli/jsext\";\n/** @deprecated use `jsext.wrap` from `@ayonli/jsext` instead. */\nconst wrap = jsext.wrap;\nexport default wrap;\n//# sourceMappingURL=wrap.js.map","import typeOf from \"./typeOf.ts\";\n/**\n * Sets a property on the target object.\n * @param value Normally this is the value bound to the property, however, it\n *  could be used to set the getter and the setter using the signature\n *  `{ get: Function, set?: Function }`.\n * @param enumerable By default, the property is non-enumerable and can't be\n *  seen by the console, use this option to make it enumerable and visible to\n *  the console.\n * @param writable By default, the property is readonly once set, use this\n *  option to allow it being writable.\n *  **This property doesn't work with setter.**\n */\nexport default function define(obj, prop, value, enumerable = false, writable = false) {\n    if (typeOf(value) === Object) {\n        if (isGetter(value) || isGetterAndSetter(value)) {\n            Object.defineProperty(obj, prop, {\n                configurable: true,\n                enumerable,\n                ...value\n            });\n            return;\n        }\n    }\n    Object.defineProperty(obj, prop, {\n        configurable: true,\n        enumerable,\n        writable,\n        value\n    });\n}\nfunction isGetter(obj) {\n    return String(Object.keys(obj)) === \"get\"\n        && typeof obj[\"get\"] === \"function\";\n}\nfunction isGetterAndSetter(obj) {\n    let sign = String(Object.keys(obj));\n    return (sign === \"get,set\" || sign === \"set,get\")\n        && typeof obj[\"get\"] === \"function\"\n        && typeof obj[\"set\"] === \"function\";\n}\n//# sourceMappingURL=define.js.map","import { isDictLike } from \"is-like\";\nimport isEmpty from \"./isEmpty.ts\";\nimport isVoid from \"./isVoid.ts\";\nexport default function diff(origin, input, deep = false) {\n    if (Array.isArray(origin) && Array.isArray(input)) {\n        return [\n            ...input.filter(value => !origin.includes(value)),\n            ...origin.filter(value => !input.includes(value))\n        ];\n    }\n    else if (isDictLike(origin) && isDictLike(input)) {\n        let keys = Reflect.ownKeys(input);\n        let _keys = Reflect.ownKeys(origin);\n        let result = {};\n        keys.forEach(key => {\n            if (origin[key] !== input[key] &&\n                !(isVoid(origin[key]) && isVoid(input[key])) // ignore void values\n            ) {\n                if (deep &&\n                    typeof origin[key] === \"object\" && origin[key] !== null &&\n                    typeof input[key] === \"object\" && input[key] !== null) {\n                    let _result = diff(origin[key], input[key], deep);\n                    if (!isEmpty(_result)) {\n                        result[key] = _result;\n                    }\n                }\n                else {\n                    result[key] = input[key];\n                }\n            }\n        });\n        _keys.forEach(key => {\n            keys.includes(key) || (result[key] = origin[key]);\n        });\n        return result;\n    }\n    else {\n        return input;\n    }\n}\n//# sourceMappingURL=diff.js.map","export default function getGlobal(prop = void 0) {\n    let _global;\n    if (typeof globalThis === \"object\") {\n        _global = globalThis;\n    }\n    else if (typeof self === \"object\") {\n        _global = self;\n    }\n    else if (typeof global === \"object\") {\n        _global = global;\n    }\n    else if (typeof window === \"object\") {\n        _global = window;\n    }\n    return _global && (prop ? _global[prop] : _global);\n}\n//# sourceMappingURL=getGlobal.js.map","/**\n * Checks if the value is an integer number (or bigint).\n *\n * @deprecated use `Number.isInteger` instead.\n */\nexport default function isInteger(value) {\n    return typeof value === \"bigint\" || Number.isInteger(value);\n}\n//# sourceMappingURL=isInteger.js.map","export default function keysOf(obj) {\n    if (Array.isArray(obj)) {\n        return obj.map((_, i) => i);\n    }\n    else {\n        return Reflect.ownKeys(obj);\n    }\n}\n//# sourceMappingURL=keysOf.js.map","import { omit as _omit } from \"@ayonli/jsext/object\";\nexport default function omit(obj, props) {\n    if (Array.isArray(obj)) {\n        return obj.filter(i => !props.includes(i));\n    }\n    else {\n        return _omit(obj, props);\n    }\n}\n//# sourceMappingURL=omit.js.map","import { pick as _pick } from \"@ayonli/jsext/object\";\nexport default function pick(obj, props) {\n    if (Array.isArray(obj)) {\n        return props.map(i => obj[i]);\n    }\n    else {\n        return _pick(obj, props);\n    }\n}\n//# sourceMappingURL=pick.js.map","import rand from \"./rand.ts\";\n/**\n * Generates a random string.\n * @param chars The possible characters.\n * @deprecated use `String.random` from `@ayonli/jsext/string/augment` instead.\n */\nexport default function randStr(length, chars = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\") {\n    let str = \"\";\n    let max = chars.length - 1;\n    while (0 < length--) {\n        str += chars[rand(0, max)];\n    }\n    return str;\n}\n//# sourceMappingURL=randStr.js.map","import { isValid } from \"@ayonli/jsext/object\";\nimport { isNumeric } from \"@ayonli/jsext/number\";\nexport default timestamp;\nfunction timestamp(input, ms = false) {\n    var _a;\n    if (typeof input === \"boolean\") {\n        ms = input;\n        input = void 0;\n    }\n    input = input || new Date();\n    if (input instanceof Date) {\n        return ms ? input.valueOf() : Math.floor(input.valueOf() / 1000);\n    }\n    else if (typeof input === \"number\") {\n        return ms ? input : Math.floor(input / 1000);\n    }\n    else {\n        let date;\n        let dateTime = String(input).trim();\n        if (dateTime.includes(\",\") && dateTime.split(\",\").every(isNumeric)) {\n            date = parseDateRawArgs(dateTime);\n        }\n        else {\n            let match = null;\n            if (match = dateTime.match(/^(\\d{1,2}):\\d{2}(:\\d{2})?/)) { // time only\n                if (((_a = match[1]) === null || _a === void 0 ? void 0 : _a.length) !== 2) {\n                    dateTime = \"0\" + dateTime;\n                }\n                if (!match[2]) {\n                    dateTime += \":00\";\n                }\n                date = new Date();\n                dateTime = date.getFullYear()\n                    + \"-\" + String(date.getMonth() + 1).padStart(2, \"0\")\n                    + \"-\" + String(date.getDate()).padStart(2, \"0\")\n                    + \" \" + dateTime;\n            }\n            date = new Date(dateTime);\n        }\n        if (String(date) !== \"Invalid Date\") {\n            return ms ? date.valueOf() : Math.floor(date.valueOf() / 1000);\n        }\n        else {\n            console.log(dateTime);\n            throw new Error(\"The input argument is not a valid date-time string\");\n        }\n    }\n}\nfunction parseDateRawArgs(str) {\n    let [Y, M, D, H, m, s, ms] = str.split(\",\").map(Number);\n    let date = new Date();\n    isValid(Y) && date.setFullYear(Y);\n    isValid(M) && date.setMonth(M);\n    isValid(D) && date.setDate(D);\n    isValid(H) && date.setHours(H);\n    isValid(m) && date.setMinutes(m);\n    isValid(s) && date.setSeconds(s);\n    isValid(ms) && date.setMilliseconds(ms);\n    return date;\n}\n//# sourceMappingURL=timestamp.js.map","import { isArrayLike, isDictLike } from \"is-like\";\nimport { ensureArray } from \"./ensureType.ts\";\n/**\n * Trims the leading and tailing spaces of a string, the string properties of\n * an object, or the string and object elements in an array.\n */\nexport default function trim(target, deep = false) {\n    if (typeof target === \"string\") {\n        return target.trim();\n    }\n    else if (isArrayLike(target, true)) {\n        return ensureArray(target).map(item => trim(item, deep));\n    }\n    else if (isDictLike(target)) {\n        const keys = [\n            ...Object.getOwnPropertyNames(target),\n            ...Object.getOwnPropertySymbols(target)\n        ];\n        return keys.reduce((result, key) => {\n            let value = target[key];\n            if (typeof value === \"string\") {\n                value = value.trim();\n            }\n            else if (deep) {\n                if (isArrayLike(value, true)) {\n                    value = ensureArray(value).map(item => {\n                        return isDictLike(item) ? trim(item, deep) : item;\n                    });\n                }\n                else if (isDictLike(value)) {\n                    value = trim(value, deep);\n                }\n            }\n            result[key] = value;\n            return result;\n        }, {});\n    }\n    else {\n        return target;\n    }\n}\n//# sourceMappingURL=trim.js.map"],"names":["isObjectWith","value","props","every","p","t","isDictLike","constructor","Object","Date","RegExp","isArrayLike","name","isObjectIdLike","obj","str","JSON","stringify","e","isEmptyDict","isTypedArrayLike","isCollectionLike","isPromiseLike","strict","Array","isArray","indexes","keys","isNonEnumLength","includes","length","map","Number","filter","isFinite","hasIterator","Symbol","iterator","i","excludeWeakOnes","WeakMap","WeakSet","isBufferLike","encoder","TextEncoder","isVoid","is","NaN","couldBeClass_2","undefined","prototype","getOwnPropertyNames","String","slice","test","hasThis","typeOf","target","arguments","TypeError","type","isClass","toString","call","BaseEmptyPrimitives","EmptyPrimitives","isEmpty","deep","Boolean","emptyPrimitives","Error","message","byteLength","len","size","Map","v","values","Set","Reflect","ownKeys","k","isNumeric","isNaN","BigInt","_a","isBetween","min","max","push","truePattern","falsePattern","nullPattern","nanPattern","infinityPattern","regexPattern","numberInterval","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","ensureArray","from","flatDeep","carrier","source","field","depth","maxDepth","flatArray","isArr","isDict","isContent","forEach","key","_isBetween","isFloat","_isNumeric","hasOwn","hasOwnProperty","pick","reduce","result","isValid","isOwnKey","isOwnMethod","method","proto","getPrototypeOf","getOwnPropertyDescriptor","asyncIterator","process","versions","node","step","loop","id","sequence","jsext","fn","wrapper","wrapped","args","this","defineProperty","configurable","enumerable","writable","bind","isSubClassOf","ctor1","ctor2","doOmit","omitEmptyObjects","omitEmptyStrings","trim","arr","omitVoid","doPatch","origin","input","ignoreEmptyStrings","isChildNode","_result","assign","rand","Math","floor","random","sleep","async","ms","Promise","resolve","setTimeout","onlyNumbers","ele","checkNumberArgument","RangeError","splitArrayLike","total","j","typeAs","_type","primitiveMap","string","number","bigint","boolean","symbol","valueOf","until","globalThis","setImmediate","cb","useThrottle","resource","interval","backgroundUpdate","gcTimer","gcInterval","tasks","jobs","setInterval","now","lastActive","delete","unref","task","get","set","cache","queue","func","daemon","throttle","handle","then","error","catch","err","job","reject","add","createThrottleTask","wrap","option","split","Buffer","encode","times","prop","isGetter","sign","isGetterAndSetter","diff","_keys","ensureType","re","match","num","_global","self","global","window","isInteger","_","keptKeys","_omit","_pick","chars","sort","compare","a","b","parseFloat","v8","Deno","navigator","userAgent","version","shouldUseNativeSort","index","getOwnPropertySymbols","item","sep","SyntaxError","offset","splitNumber","isBuffer","buf","indexOf","splitBuffer","ctor","list","keyChunks","chunk","create","splitObject","date","dateTime","Y","M","D","H","m","s","setFullYear","setMonth","setDate","setHours","setMinutes","setSeconds","setMilliseconds","parseDateRawArgs","getFullYear","getMonth","padStart","getDate","console","log"],"mappings":"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","x_google_ignoreList":[0,3,6,12,15,16,17,18,19,20,22,28]}